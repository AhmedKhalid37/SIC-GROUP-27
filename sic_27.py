# -*- coding: utf-8 -*-
"""SIC_27

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/ahmedkhalid37/sic-27.6fcaa162-6f5e-4473-89d1-f5bd5638851b.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20251212/auto/storage/goog4_request%26X-Goog-Date%3D20251212T184641Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D793fcec5035a25132e57447bddb7fe340956b6c7179fbd3636e6e47ede3d95398b3f4f18491d92c49f1ff98762f5ca50a379f2a3799211142ca671574dd553b13948f3923cbb740bfa90dfd7c549b111c5dc99fe98e5053a51a10dd106e73cee80a40f9d355ee5a44bb90f17edc42d6f1a23594c04185bb01ec372ffd5caeb2f00e9e58d539d7ee7721e34e30a74e01784bd8b3c645615736675ddc1f8c8a3e4e676a222b6dbab68a342faf3c56b1e1ad58649ac8530a519b4f5efb8724c12226f43b676417e0997fc6d562ac09678d1d62e04e6174b02e900e93473a7478a9d3ff3cce2fccb8f8d52263650a127ef26d571e90d65bfdb9abadadd51655eec00
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub
mbsoroush_car_camera_photos_path = kagglehub.dataset_download('mbsoroush/car-camera-photos')

print('Data source import complete.')

!pip install ultralytics

import os
import glob
import random
import cv2
import matplotlib.pyplot as plt
import numpy as np
from ultralytics import YOLO
from PIL import Image, ImageDraw, ImageFont
from collections import Counter

# 1. Load Model
model = YOLO('yolov8n.pt')

# 2. Constants
KNOWN_WIDTH = 1.8
FOCAL_LENGTH = 1200

# 3. Logic Functions
def get_distance(box_width_px):
    if box_width_px == 0: return 999.0
    return (KNOWN_WIDTH * FOCAL_LENGTH) / box_width_px

def get_status(dist, x_center, img_width):
    lane_min = img_width * 0.3
    lane_max = img_width * 0.7

    if x_center < lane_min or x_center > lane_max:
        return "O", "IGNORE", (128, 128, 128)

    if dist < 15.0:
        return "VC", "BRAKE", (255, 0, 0)
    elif dist < 45.0:
        return "C", "SLOW", (255, 255, 0)
    elif dist < 70.0:
        return "N", "SAFE", (0, 255, 0)
    else:
        return "F", "SAFE", (0, 255, 0)

def load_fonts():
    possible_fonts = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
        "arial.ttf",
        "Arial.ttf"
    ]
    font_large = None
    font_small = None

    for f_path in possible_fonts:
        try:
            font_large = ImageFont.truetype(f_path, 40)
            font_small = ImageFont.truetype(f_path, 15)
            break
        except IOError:
            continue

    if font_large is None:
        font_large = ImageFont.load_default()
        font_small = ImageFont.load_default()

    return font_large, font_small

# ==========================================
# PART 4: FIND & PROCESS IMAGES DIRECTLY
# ==========================================

# 1. Find all images in the Input directory
print("Searching for images in /kaggle/input...")
all_images = glob.glob('/kaggle/input/**/*.jpg', recursive=True) + \
             glob.glob('/kaggle/input/**/*.png', recursive=True)

if not all_images:
    print("No images found. Make sure you added a dataset!")
else:
    # 2. Pick 3 Random Images directly from the source
    # We use min() to ensure we don't crash if there are fewer than 3 images
    selected_files = random.sample(all_images, min(3, len(all_images)))

    print(f"Processing {len(selected_files)} images...")
    results = model(selected_files)

    # --- PRINT TEXT REPORT ---
    print("="*60)
    print("SELF-DRIVING SAFETY REPORT")
    print("="*60)
    print("LEGEND: [VC]=Very Close (<15m) | [C]=Close (<45m)")
    print("[N]=Normal | [O]=Other Lane")
    print("-" * 60)

    plt.figure(figsize=(20, 10))

    font_large, font_small = load_fonts()

    for i, r in enumerate(results):
        img_bgr = r.orig_img.copy()
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        pil_img = Image.fromarray(img_rgb)
        draw = ImageDraw.Draw(pil_img)

        img_h, img_w = pil_img.size[1], pil_img.size[0]

        detected_cars = []
        boxes = r.boxes
        for box in boxes:
            cls_id = int(box.cls[0])
            if cls_id in [2, 3, 5, 7]:
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                w_box = x2 - x1
                c_x = (x1 + x2) / 2

                dist = get_distance(w_box)
                code, action, color = get_status(dist, c_x, img_w)

                detected_cars.append({
                    'dist': dist,
                    'coords': (x1, y1, x2, y2),
                    'color': color,
                    'code': code,
                    'action': action
                })

        detected_cars.sort(key=lambda x: x['dist'])
        top_3_cars = detected_cars[:3]

        print(f"Scenario {i+1}:")
        if not top_3_cars: print("   (No vehicles detected)")
        for idx, car in enumerate(top_3_cars):
            d = car['dist']
            c = car['code']
            a = car['action']
            print(f"   Object {idx+1}: {d:.1f}m \t-> Code: [{c}] Action: {a}")
        print("-" * 20)

        for car in top_3_cars:
            code_text = car['code']
            action_text = car['action']
            color = car['color']
            x1, y1, x2, y2 = car['coords']
            w_box = x2 - x1

            draw.rectangle([x1, y1, x2, y2], outline=color, width=4)

            bbox_code = draw.textbbox((0, 0), code_text, font=font_large)
            w_code = bbox_code[2] - bbox_code[0]
            h_code = bbox_code[3] - bbox_code[1]

            bbox_action = draw.textbbox((0, 0), action_text, font=font_small)
            w_action = bbox_action[2] - bbox_action[0]
            h_action = bbox_action[3] - bbox_action[1]

            box_center_x = x1 + (w_box / 2)
            x_code = box_center_x - (w_code / 2)
            x_action = box_center_x - (w_action / 2)

            padding = 5
            y_action = y1 - h_action - padding
            y_code = y_action - h_code - padding

            if y_code < 0:
                y_code = y1 + padding
                y_action = y_code + h_code + padding

            draw.text((x_code, y_code), code_text, fill=color, font=font_large)
            draw.text((x_action, y_action), action_text, fill=color, font=font_small)

        plt.subplot(1, 3, i+1)
        plt.imshow(pil_img)
        plt.axis('off')
        plt.title(f"Scenario {i+1}")

    plt.show()